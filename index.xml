<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on Pgjdbc</title><link>https://utkar-sh-ukla.github.io/testing/</link><description>Recent content in Home on Pgjdbc</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 19 Jun 2022 22:46:55 +0530</lastBuildDate><atom:link href="https://utkar-sh-ukla.github.io/testing/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter1/intro/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter1/intro/</guid><description>Java Database Connectivity (JDBC) is an application programming interface (API) for the programming language Java, which defines how a client may access a database. It is part of the Java Standard Edition platform and provides methods to query and update data in a database, and is oriented towards relational databases.
PostgreSQL JDBC Driver (PgJDBC for short) allows Java programs to connect to a PostgreSQL database using standard, database independent Java code.</description></item><item><title>Setting up the JDBC Driver</title><link>https://utkar-sh-ukla.github.io/testing/documentation/setup/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/setup/</guid><description>Setting up the JDBC DriverThis section describes the steps you need to take before you can write or run programs that use the JDBC interface.
Getting the Driver Precompiled versions of the driver can be downloaded from the PostgreSQL™ JDBC web site.
Alternatively you can build the driver from source, but you should only need to do this if you are making changes to the source code. To build the JDBC driver, you need gradle and a JDK (currently at least jdk1.</description></item><item><title>Getting the Driver</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter2/setup/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter2/setup/</guid><description>Precompiled versions of the driver can be downloaded from the PostgreSQL™ JDBC web site.
Alternatively you can build the driver from source, but you should only need to do this if you are making changes to the source code. To build the JDBC driver, you need gradle and a JDK (currently at least jdk1.8) .
If you have several Java compilers installed, maven will use the first one on the path.</description></item><item><title>Initializing the Driver</title><link>https://utkar-sh-ukla.github.io/testing/documentation/use/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/use/</guid><description>Initializing the DriverThis section describes how to load and initialize the JDBC driver in your programs.
Importing JDBC Any source that uses JDBC needs to import the java.sql package, using:
import java.sql.*; NOTE You should not import the org.postgresql package unless you are not using standard PostgreSQL™ extensions to the JDBC API.
Loading the Driver Applications do not need to explicitly load the org.</description></item><item><title>Setting up the Class Path</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter2/classpath/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter2/classpath/</guid><description>To use the driver, the JAR archive named postgresql-MM.nn.pp.jar needs to be included in the class path, either by putting it in the CLASSPATH environment variable, or by using flags on the java command line.
For instance, assume we have an application that uses the JDBC driver to access a database, and that application is installed as /usr/local/lib/myapp.jar. The PostgreSQL™ JDBC driver installed as /usr/local/pgsql/share/java/postgresql-MM.nn.pp.jar. To run the application, we would use:</description></item><item><title>Using SSL</title><link>https://utkar-sh-ukla.github.io/testing/documentation/ssl/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/ssl/</guid><description>Configuring the ServerConfiguring the PostgreSQL™ server for SSL is covered in the main documentation, so it will not be repeated here. There are also instructions in the source certdir Before trying to access your SSL enabled server from Java, make sure you can get to it via psql. You should see output like the following if you have established a SSL connection.
$ ./bin/psql -h localhost -U postgres psql (9.6.2) SSL connection (protocol: TLSv1.</description></item><item><title>Issuing a Query and Processing the Result</title><link>https://utkar-sh-ukla.github.io/testing/documentation/query/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/query/</guid><description>Issuing a Query and Processing the ResultAny time you want to issue SQL statements to the database, you require a Statement
or PreparedStatement instance. Once you have a Statement or PreparedStatement , you can use issue a query. This will return a ResultSet instance, which contains the entire result (see the section called “Getting results based on a cursor” here for how to alter this behaviour). Example 5.1, “Processing a Simple Query in JDBC” illustrates this process.</description></item><item><title>Preparing the Database Server for JDBC</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter2/prepare/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter2/prepare/</guid><description>Out of the box, Java does not support unix sockets so the PostgreSQL server must be configured to allow TCP/IP connections. Starting with server version 8.0 TCP/IP connections are allowed from localhost. To allow connections to other interfaces than the loopback interface, you must modify the postgresql.conf file&amp;rsquo;s listen_addresses setting.
Once you have made sure the server is correctly listening for TCP/IP connections the next step is to verify that users are allowed to connect to the server.</description></item><item><title>Calling Stored Functions and Procedures</title><link>https://utkar-sh-ukla.github.io/testing/documentation/callproc/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/callproc/</guid><description>Calling Stored Functions and ProceduresPostgreSQL™ supports two types of stored objects, functions that can return a result value and - starting from v11 - procedures that can perform transaction control. Both types of stored objects are invoked using CallableStatement and the standard JDBC escape call syntax {call storedobject(?)} . The escapeSyntaxCallMode connection property controls how the driver transforms the call syntax to invoke functions or procedures.
The default mode, select , supports backwards compatibility for existing applications and supports function invocation only.</description></item><item><title>Creating a Database</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter2/your-database/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter2/your-database/</guid><description>When creating a database to be accessed via JDBC it is important to select an appropriate encoding for your data. Many other client interfaces do not care what data you send back and forth, and will allow you to do inappropriate things, but Java makes sure that your data is correctly encoded. Do not use a database that uses the SQL_ASCII encoding. This is not a real encoding and you will have problems the moment you store data in it that does not fit in the seven bit ASCII character set.</description></item><item><title>Importing JDBC</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter3/use/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter3/use/</guid><description>Any source that uses JDBC needs to import the java.sql package, using:
import java.sql.*; Note You should not import the org.postgresql package unless you are not using standard PostgreSQL™ extensions to the JDBC API.</description></item><item><title>Storing Binary Data</title><link>https://utkar-sh-ukla.github.io/testing/documentation/binary-data/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/binary-data/</guid><description>Storing Binary DataPostgreSQL™ provides two distinct ways to store binary data. Binary data can be stored in a table using the data type BYTEA or by using the Large Object feature which stores the binary data in a separate table in a special format and refers to that table by storing a value of type OID in your table.
In order to determine which method is appropriate you need to understand the limitations of each method.</description></item><item><title>JDBC escapes</title><link>https://utkar-sh-ukla.github.io/testing/documentation/escapes/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/escapes/</guid><description>JDBC escapesThe JDBC specification (like the ODBC specification) acknowledges the fact that some vendor specific SQL may be required for certain RDBMS features. To aid developers in writing portable JDBC applications across multiple database products, a special escape syntax is used to specify the generic commands the developer wants to be run. The JDBC driver translates these escape sequences into native syntax for its specific database. For more information consult the Java DB Technical Documentation.</description></item><item><title>Loading the Driver</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter3/load/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter3/load/</guid><description>Applications do not need to explicitly load the org.postgresql.Driver class because the pgjdbc driver jar supports the Java Service Provider mechanism. The driver will be loaded by the JVM when the application connects to PostgreSQL™ (as long as the driver&amp;rsquo;s jar file is on the classpath).
Note Prior to Java 1.6, the driver had to be loaded by the application - either by calling
Class.forName(&amp;#34;org.postgresql.Driver&amp;#34;); or by passing the driver class name as a JVM parameter.</description></item><item><title>Connecting to the Database</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter3/connect/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter3/connect/</guid><description>With JDBC, a database is represented by a URL (Uniform Resource Locator). With PostgreSQL, this takes one of the following forms:
jdbc:postgresql:database jdbc:postgresql:/ jdbc:postgresql://host/database jdbc:postgresql://host/ jdbc:postgresql://host:port/database jdbc:postgresql://host:port/ The parameters have the following meanings:
host
The host name of the server. Defaults to localhost. To specify an IPv6 address your must enclose the host parameter with square brackets, for example:
jdbc:postgresql://[::1]:5740/accounting
port
The port number the server is listening on.</description></item><item><title>PostgreSQL™ Extensions to the JDBC API</title><link>https://utkar-sh-ukla.github.io/testing/documentation/server-prepare/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/server-prepare/</guid><description>PostgreSQL™ Extensions to the JDBC APIPostgreSQL™ is an extensible database system. You can add your own functions to the server, which can then be called from queries, or even add your own data types. As these are facilities unique to PostgreSQL™, we support them from Java, with a set of extension APIs. Some features within the core of the standard driver actually use these extensions to implement Large Objects, etc.</description></item><item><title>Configuring the Server</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter4/ssl/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter4/ssl/</guid><description>Configuring the PostgreSQL™ server for SSL is covered in the main documentation, so it will not be repeated here. There are also instructions in the source certdir Before trying to access your SSL enabled server from Java, make sure you can get to it via psql. You should see output like the following if you have established a SSL connection.
$ ./bin/psql -h localhost -U postgres psql (9.6.2) SSL connection (protocol: TLSv1.</description></item><item><title>Using the Driver in a Multithreaded or a Servlet Environment</title><link>https://utkar-sh-ukla.github.io/testing/documentation/thread/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/thread/</guid><description>Using the Driver in a Multithreaded or a Servlet EnvironmentThe PostgreSQL™ JDBC driver is not thread safe. The PostgreSQL server is not threaded. Each connection creates a new process on the server; as such any concurrent requests to the process would have to be serialized. The driver makes no guarantees that methods on connections are synchronized. It will be up to the caller to synchronize calls to the driver.
A notable exception is org/postgresql/jdbc/TimestampUtils.</description></item><item><title>Connection Pools and Data Sources</title><link>https://utkar-sh-ukla.github.io/testing/documentation/datasource/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/datasource/</guid><description>Connection Pools and Data SourcesJDBC 2 introduced standard connection pooling features in an add-on API known as the JDBC 2.0 Optional Package (also known as the JDBC 2.0 Standard Extension). These features have since been included in the core JDBC 3 API.
The JDBC API provides a client and a server interface for connection pooling. The client interface is javax.sql.DataSource, which is what application code will typically use to acquire a pooled database connection.</description></item><item><title>Custom SSLSocketFactory</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter4/ssl-factory/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter4/ssl-factory/</guid><description>PostgreSQL™ provides a way for developers to customize how a SSL connection is established. This may be used to provide a custom certificate source or other extensions by allowing the developer to create their own SSLContext instance. The connection URL parameters sslfactory allow the user to specify which custom class to use for creating the SSLSocketFactory. The class name specified by sslfactory must extend javax.net.ssl.SSLSocketFactory and be available to the driver&amp;rsquo;s classloader.</description></item><item><title>Configuring the Client</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter4/ssl-client/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter4/ssl-client/</guid><description>There are a number of connection parameters for configuring the client for SSL. See SSL Connection parameters
The simplest being ssl=true, passing this into the driver will cause the driver to validate both the SSL certificate and verify the hostname (same as verify-full). Note this is different than libpq which defaults to a non-validating SSL connection.
In this mode, when establishing a SSL connection the JDBC driver will validate the server&amp;rsquo;s identity preventing &amp;ldquo;man in the middle&amp;rdquo; attacks.</description></item><item><title>Logging using java.util.logging</title><link>https://utkar-sh-ukla.github.io/testing/documentation/logging/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/logging/</guid><description>Logging using java.util.loggingThe PostgreSQL JDBC Driver supports the use of logging (or tracing) to help resolve issues with the PgJDBC Driver when is used in your application.
The PgJDBC Driver uses the logging APIs of java.util.logging that is part of Java since JDK 1.4, which makes it a good choice for the driver since it doesn&amp;rsquo;t add any external dependency for a logging framework. java.util.logging is a very rich and powerful tool, it&amp;rsquo;s beyond the scope of these docs to explain how to use it to it&amp;rsquo;s full potential, for that please refer to Java Logging Overview.</description></item><item><title>Further Reading</title><link>https://utkar-sh-ukla.github.io/testing/documentation/reading/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/reading/</guid><description>Further ReadingIf you have not yet read it, you are advised you read the JDBC API Documentation (supplied with Oracle&amp;rsquo;s JDK) and the JDBC Specification. Both are available from http://www.oracle.com/technetwork/java/javase/jdbc/index.html.
http://jdbc.postgresql.org/index.html contains updated information not included in this manual including Javadoc class documentation and a FAQ. Additionally it offers precompiled drivers.</description></item><item><title>Issuing a Query and Processing the Result</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter5/query/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter5/query/</guid><description>Any time you want to issue SQL statements to the database, you require a Statement or PreparedStatement instance. Once you have a Statement or PreparedStatement, you can use issue a query. This will return a ResultSet instance, which contains the entire result (see the section called “Getting results based on a cursor” here for how to alter this behaviour). Example 5.1, “Processing a Simple Query in JDBC” illustrates this process.</description></item><item><title>Using the Statement or PreparedStatement Interface</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter5/statement/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter5/statement/</guid><description>The following must be considered when using the Statement or PreparedStatement interface:
You can use a single Statement instance as many times as you want. You could create one as soon as you open the connection and use it for the connection&amp;rsquo;s lifetime. But you have to remember that only one ResultSet can exist per Statement or PreparedStatement at a given time. If you need to perform a query while processing a ResultSet, you can simply create and use another Statement.</description></item><item><title>Using the ResultSet Interface</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter5/resultset/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter5/resultset/</guid><description>The following must be considered when using the ResultSet interface:
Before reading any values, you must call next(). This returns true if there is a result, but more importantly, it prepares the row for processing. You must close a ResultSet by calling close() once you have finished using it. Once you make another query with the Statement used to create a ResultSet, the currently open ResultSet instance is closed automatically.</description></item><item><title>Performing Updates</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter5/update/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter5/update/</guid><description>To change data (perform an INSERT, UPDATE, or DELETE) you use the executeUpdate() method. This method is similar to the method executeQuery() used to issue a SELECT statement, but it doesn&amp;rsquo;t return a ResultSet; instead it returns the number of rows affected by the INSERT, UPDATE, or DELETE statement. Example 5.3, “Deleting Rows in JDBC” illustrates the usage.
Example 5.3. Deleting Rows in JDBC
This example will issue a simple DELETE statement and print out the number of rows deleted.</description></item><item><title>Creating and Modifying Database Objects</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter5/ddl/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter5/ddl/</guid><description>To create, modify or drop a database object like a table or view you use the execute() method. This method is similar to the method executeQuery(), but it doesn&amp;rsquo;t return a result. Example 5.4, “Dropping a Table in JDBC illustrates the usage.
Example 5.4. Dropping a Table in JDBC
This example will drop a table.
Statement st = conn.createStatement(); st.execute(&amp;#34;DROP TABLE mytable&amp;#34;); st.close();</description></item><item><title>Using Java 8 Date and Time classes</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter5/java8-date-time/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter5/java8-date-time/</guid><description>The PostgreSQL™ JDBC driver implements native support for the Java 8 Date and Time API (JSR-310) using JDBC 4.2.
Table 5.1. Supported Java 8 Date and Time classes
PostgreSQL™ Java SE 8 DATE LocalDate TIME [ WITHOUT TIME ZONE ] LocalTime TIMESTAMP [ WITHOUT TIME ZONE ] LocalDateTime TIMESTAMP WITH TIME ZONE OffsetDateTime This is closely aligned with tables B-4 and B-5 of the JDBC 4.</description></item><item><title>Calling Stored Functions and Procedures</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter6/callproc/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter6/callproc/</guid><description>PostgreSQL™ supports two types of stored objects, functions that can return a result value and - starting from v11 - procedures that can perform transaction control. Both types of stored objects are invoked using CallableStatement and the standard JDBC escape call syntax {call storedobject(?)}. The escapeSyntaxCallMode connection property controls how the driver transforms the call syntax to invoke functions or procedures.
The default mode, select, supports backwards compatibility for existing applications and supports function invocation only.</description></item><item><title>Storing Binary Data</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter7/binary-data/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter7/binary-data/</guid><description>PostgreSQL™ provides two distinct ways to store binary data. Binary data can be stored in a table using the data type BYTEA or by using the Large Object feature which stores the binary data in a separate table in a special format and refers to that table by storing a value of type OID in your table.
In order to determine which method is appropriate you need to understand the limitations of each method.</description></item><item><title>JDBC escapes</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter8/escapes/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter8/escapes/</guid><description>The JDBC specification (like the ODBC specification) acknowledges the fact that some vendor specific SQL may be required for certain RDBMS features. To aid developers in writing portable JDBC applications across multiple database products, a special escape syntax is used to specify the generic commands the developer wants to be run. The JDBC driver translates these escape sequences into native syntax for its specific database. For more information consult the Java DB Technical Documentation.</description></item><item><title>Escape for outer joins</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter8/outer-joins-escape/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter8/outer-joins-escape/</guid><description>You can specify outer joins using the following syntax: {oj table (LEFT|RIGHT|FULL) OUTER JOIN (table | outer-join) ON search-condition }
For example :
ResultSet rs = stmt.executeQuery( &amp;#34;select * from {oj a left outer join b on (a.i=b.i)} &amp;#34;);</description></item><item><title>Date-time escapes</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter8/escapes-datetime/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter8/escapes-datetime/</guid><description>The JDBC specification defines escapes for specifying date, time and timestamp values which are supported by the driver.
date
{d 'yyyy-mm-dd'} which is translated to DATE 'yyyy-mm-dd'
time
{t 'hh:mm:ss'} which is translated to TIME 'hh:mm:ss'
timestamp
{ts 'yyyy-mm-dd hh:mm:ss.f...'} which is translated to TIMESTAMP 'yyyy-mm-dd hh:mm:ss.f'The fractional seconds (.f&amp;hellip;) portion of the TIMESTAMP can be omitted.</description></item><item><title>Escaped scalar functions</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter8/escaped-functions/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter8/escaped-functions/</guid><description>The JDBC specification defines functions with an escape call syntax : {fn function_name(arguments)}. The following tables show which functions are supported by the PostgreSQL™ driver. The driver supports the nesting and the mixing of escaped functions and escaped values. The appendix C of the JDBC specification describes the functions.
Some functions in the following tables are translated but reported as not supported because they are duplicating or changing their order of the arguments.</description></item><item><title>PostgreSQL™ Extensions to the JDBC API</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter9/ext/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter9/ext/</guid><description>PostgreSQL™ is an extensible database system. You can add your own functions to the server, which can then be called from queries, or even add your own data types. As these are facilities unique to PostgreSQL™, we support them from Java, with a set of extension APIs. Some features within the core of the standard driver actually use these extensions to implement Large Objects, etc.
Accessing the ExtensionsTo access some of the extensions, you need to use some extra methods in the org.</description></item><item><title>Geometric Data Types</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter9/geometric/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter9/geometric/</guid><description>PostgreSQL™ has a set of data types that can store geometric features into a table. These include single points, lines, and polygons. We support these types in Java with the org.postgresql.geometric package. Please consult the Javadoc mentioned in Chapter 13, Further Reading for details of available classes and features.
Example 9.1. Using the CIRCLE datatype JDBC
import java.sql.*; import org.postgresql.geometric.PGpoint; import org.postgresql.geometric.PGcircle; public class GeometricTest { public static void main(String args[]) throws Exception { String url = &amp;#34;jdbc:postgresql://localhost:5432/test&amp;#34;; try (Connection conn = DriverManager.</description></item><item><title>Large Objects</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter9/largeobjects/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter9/largeobjects/</guid><description>Large objects are supported in the standard JDBC specification. However, that interface is limited, and the API provided by PostgreSQL™ allows for random access to the objects contents, as if it was a local file.
The org.postgresql.largeobject package provides to Java the libpq C interface&amp;rsquo;s large object API. It consists of two classes, LargeObjectManager, which deals with creating, opening and deleting large objects, and LargeObject which deals with an individual object.</description></item><item><title>Listen / Notify</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter9/listennotify/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter9/listennotify/</guid><description>Listen and Notify provide a simple form of signal or interprocess communication mechanism for a collection of processes accessing the same PostgreSQL™ database. For more information on notifications consult the main server documentation. This section only deals with the JDBC specific aspects of notifications.
Standard LISTEN, NOTIFY, and UNLISTEN commands are issued via the standard Statement interface. To retrieve and process retrieved notifications the Connection must be cast to the PostgreSQL™ specific extension interface PGConnection.</description></item><item><title>Server Prepared Statements</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter9/server-prepare/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter9/server-prepare/</guid><description>Motivation The PostgreSQL™ server allows clients to compile sql statements that are expected to be reused to avoid the overhead of parsing and planning the statement for every execution. This functionality is available at the SQL level via PREPARE and EXECUTE beginning with server version 7.3, and at the protocol level beginning with server version 7.4, but as Java developers we really just want to use the standard PreparedStatement interface.</description></item><item><title>Parameter Status Messages</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter9/parameterstatus/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter9/parameterstatus/</guid><description>Parameter Status MessagesPostgreSQL supports server parameters, also called server variables or, internally, Grand Unified Configuration (GUC) variables. These variables are manipulated by the SET command, postgresql.conf, ALTER SYSTEM SET, ALTER USER SET, ALTER DATABASE SET, the set_config(...) SQL-callable function, etc. See the PostgreSQL manual.
For a subset of these variables the server will automatically report changes to the value to the client driver and application. These variables are known internally as GUC_REPORT variables after the name of the flag that enables the functionality.</description></item><item><title>Physical and Logical replication API</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter9/replication/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter9/replication/</guid><description>OverviewPostgres 9.4 (released in December 2014) introduced a new feature called logical replication. Logical replication allows changes from a database to be streamed in real-time to an external system. The difference between physical replication and logical replication is that logical replication sends data over in a logical format whereas physical replication sends data over in a binary format. Additionally logical replication can send over a single table, or database. Binary replication replicates the entire cluster in an all or nothing fashion; which is to say there is no way to get a specific table or database using binary replication</description></item><item><title>Arrays</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter9/arrays/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter9/arrays/</guid><description>PostgreSQL™ provides robust support for array data types as column types, function arguments and criteria in where clauses. There are several ways to create arrays with pgjdbc.
The java.sql.Connection.createArrayOf(String, Object[]) can be used to create an java.sql.Array from Object[] instances (Note: this includes both primitive and object multi-dimensional arrays). A similar method org.postgresql.PGConnection.createArrayOf(String, Object) provides support for primitive array types. The java.sql.Array object returned from these methods can be used in other methods, such as PreparedStatement.</description></item><item><title>Using the Driver in a Multithreaded or a Servlet Environment</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter10/thread/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter10/thread/</guid><description>The PostgreSQL™ JDBC driver is not thread safe. The PostgreSQL server is not threaded. Each connection creates a new process on the server; as such any concurrent requests to the process would have to be serialized. The driver makes no guarantees that methods on connections are synchronized. It will be up to the caller to synchronize calls to the driver.
A notable exception is org/postgresql/jdbc/TimestampUtils.java which is threadsafe.</description></item><item><title>Connection Pools and Data Sources</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter11/datasource/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter11/datasource/</guid><description>JDBC 2 introduced standard connection pooling features in an add-on API known as the JDBC 2.0 Optional Package (also known as the JDBC 2.0 Standard Extension). These features have since been included in the core JDBC 3 API.
OverviewThe JDBC API provides a client and a server interface for connection pooling. The client interface is javax.sql.DataSource, which is what application code will typically use to acquire a pooled database connection. The server interface is javax.</description></item><item><title>Application Servers ConnectionPoolDataSource</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter11/ds-cpds/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter11/ds-cpds/</guid><description>PostgreSQL™ includes one implementation of ConnectionPoolDataSource named org.postgresql.ds.PGConnectionPoolDataSource.
JDBC requires that a ConnectionPoolDataSource be configured via JavaBean properties, shown in Table 11.1, “ConnectionPoolDataSource Configuration Properties”, so there are get and set methods for each of these properties.
Table 11.1. ConnectionPoolDataSource Configuration Properties
Property Type Description serverName STRING PostgreSQL™ database server host name databaseName STRING PostgreSQL™ database name portNumber INT TCP port which the PostgreSQL™ database server is listening on (or 0 to use the default port) user STRING User used to make database connections password STRING Password used to make database connections ssl BOOLEAN If true, use SSL encrypted connections (default false) sslfactory STRING Custom javax.</description></item><item><title>Applications DataSource</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter11/ds-ds/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter11/ds-ds/</guid><description>PostgreSQL™ includes two implementations of DataSource, as shown in Table 11.2, “DataSource Implementations”. One that does pooling and the other that does not. The pooling implementation does not actually close connections when the client calls the close method, but instead returns the connections to a pool of available connections for other clients to use. This avoids any overhead of repeatedly opening and closing connections, and allows a large number of clients to share a small number of database connections.</description></item><item><title>Data Sources and JNDI</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter11/jndi/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter11/jndi/</guid><description>All the ConnectionPoolDataSource and DataSource implementations can be stored in JNDI. In the case of the nonpooling implementations, a new instance will be created every time the object is retrieved from JNDI, with the same settings as the instance that was stored. For the pooling implementations, the same instance will be retrieved as long as it is available (e.g., not a different JVM retrieving the pool from JNDI), or a new instance with the same settings created otherwise.</description></item><item><title>Tomcat setup</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter11/tomcat/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter11/tomcat/</guid><description>Note The postgresql.jar file must be placed in $CATALINA_HOME/common/lib in both Tomcat 4 and 5.
The absolute easiest way to set this up in either tomcat instance is to use the admin web application that comes with Tomcat, simply add the datasource to the context you want to use it in.
Setup for Tomcat 4 place the following inside the &amp;lt;Context&amp;gt; tag inside conf/server.xml
&amp;lt;Resource name=&amp;#34;jdbc/postgres&amp;#34; scope=&amp;#34;Shareable&amp;#34; type=&amp;#34;javax.sql.DataSource&amp;#34;/&amp;gt; &amp;lt;ResourceParams name=&amp;#34;jdbc/postgres&amp;#34;&amp;gt; &amp;lt;parameter&amp;gt; &amp;lt;name&amp;gt;validationQuery&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;select version();&amp;lt;/value&amp;gt; &amp;lt;/parameter&amp;gt; &amp;lt;parameter&amp;gt; &amp;lt;name&amp;gt;url&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;jdbc:postgresql://localhost/davec&amp;lt;/value&amp;gt; &amp;lt;/parameter&amp;gt; &amp;lt;parameter&amp;gt; &amp;lt;name&amp;gt;password&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;davec&amp;lt;/value&amp;gt; &amp;lt;/parameter&amp;gt; &amp;lt;parameter&amp;gt; &amp;lt;name&amp;gt;maxActive&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;4&amp;lt;/value&amp;gt; &amp;lt;/parameter&amp;gt; &amp;lt;parameter&amp;gt; &amp;lt;name&amp;gt;maxWait&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;5000&amp;lt;/value&amp;gt; &amp;lt;/parameter&amp;gt; &amp;lt;parameter&amp;gt; &amp;lt;name&amp;gt;driverClassName&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;org.</description></item><item><title>Logging using java.util.logging</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter12/logging/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter12/logging/</guid><description>OverviewThe PostgreSQL JDBC Driver supports the use of logging (or tracing) to help resolve issues with the PgJDBC Driver when is used in your application.
The PgJDBC Driver uses the logging APIs of java.util.logging that is part of Java since JDK 1.4, which makes it a good choice for the driver since it doesn&amp;rsquo;t add any external dependency for a logging framework. java.util.logging is a very rich and powerful tool, it&amp;rsquo;s beyond the scope of these docs to explain how to use it to it&amp;rsquo;s full potential, for that please refer to Java Logging Overview.</description></item><item><title>Further Reading</title><link>https://utkar-sh-ukla.github.io/testing/documentation/chapter13/reading/</link><pubDate>Sun, 19 Jun 2022 22:46:55 +0530</pubDate><guid>https://utkar-sh-ukla.github.io/testing/documentation/chapter13/reading/</guid><description>If you have not yet read it, you are advised you read the JDBC API Documentation (supplied with Oracle&amp;rsquo;s JDK) and the JDBC Specification. Both are available from http://www.oracle.com/technetwork/java/javase/jdbc/index.html.
http://jdbc.postgresql.org/index.html contains updated information not included in this manual including Javadoc class documentation and a FAQ. Additionally it offers precompiled drivers.</description></item></channel></rss>